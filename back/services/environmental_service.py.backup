"""
Environmental Data Service
Handles fetching and processing environmental data from Copernicus CDS
"""
from datetime import datetime, timedelta
import os
import tempfile
import requests
import cdsapi
from flask import current_app

try:
    import xarray as xr
                              'time': ['00:00', '12:00'],
                            'area': [north, west, south, east],
                            'format': 'netcdf'
                        },
                        temp_path
                    )
                    
                    # If we get here, the request succeeded!
                    break
                    
                except Exception as e:
                    last_error = e
                    if os.path.exists(temp_path):
                        os.unlink(temp_path)
                    
                    if "not available yet" in str(e).lower():
                        print(f"[INFO] Data not available for {date_str}, trying older date...")
                        continue
                    else:
                        raise
            
            # Check if we found valid data
            if date_str and os.path.exists(temp_path):
                try:AY_AVAILABLE = True
except ImportError:
    XARRAY_AVAILABLE = False
    print("[WARNING] xarray not installed. Install with: pip install xarray netCDF4")


class EnvironmentalService:
    """Service for environmental data operations using Copernicus CDS API"""
    
    def __init__(self):
        """Initialize the environmental service with Copernicus client"""
        self.copernicus_url = None
        self.copernicus_key = None
        self.cds_client = None
    
    def _find_most_recent_date(self, max_days_back=30):
        """
        Find the most recent date with available data.
        Tries progressively older dates until data is found.
        
        Args:
            max_days_back (int): Maximum number of days to look back
            
        Returns:
            tuple: (date_str, days_back) or (None, None) if no data found
        """
        for days_back in range(1, max_days_back + 1):
            date = datetime.now() - timedelta(days=days_back)
            date_str = date.strftime('%Y-%m-%d')
            # We'll try this date and let the API call handle the validation
            # The first successful call will cache the working date
            return date_str, days_back
        return None, None
    
    def _init_copernicus_client(self):
        """Initialize Copernicus CDS API client lazily"""
        if self.cds_client is None:
            try:
                self.copernicus_url = current_app.config.get('COPERNICUS_API_URL')
                self.copernicus_key = current_app.config.get('COPERNICUS_API_KEY')
                
                if self.copernicus_key:
                    # Crear archivo .cdsapirc si no existe
                    # Esto permite funcionar tanto en desarrollo local como en producción
                    cdsapirc_path = os.path.expanduser('~/.cdsapirc')
                    
                    # Verificar si la key ya tiene formato UID:KEY o solo KEY
                    # Nuevas cuentas de Copernicus solo usan KEY sin UID
                    if ':' not in self.copernicus_key:
                        # Formato nuevo (solo API key) - Usar directamente
                        api_key_formatted = self.copernicus_key
                        print(f"[INFO] Using new Copernicus API format (personal access token)")
                    else:
                        # Formato antiguo (UID:KEY) - Mantener como está
                        api_key_formatted = self.copernicus_key
                        print(f"[INFO] Using legacy Copernicus API format (UID:KEY)")
                    
                    # Solo crear si no existe o si está vacío
                    if not os.path.exists(cdsapirc_path) or os.path.getsize(cdsapirc_path) == 0:
                        with open(cdsapirc_path, 'w') as f:
                            f.write(f"url: {self.copernicus_url}\n")
                            f.write(f"key: {api_key_formatted}\n")
                        print(f"[INFO] Created .cdsapirc file at {cdsapirc_path}")
                    
                    # Inicializar cliente (ahora encontrará el archivo)
                    self.cds_client = cdsapi.Client()
                    print(f"[INFO] ✅ Copernicus client initialized successfully")
                else:
                    print(f"[WARNING] ❌ No COPERNICUS_API_KEY found in environment")
            except Exception as e:
                print(f"[ERROR] Could not initialize Copernicus client: {e}")
                # No lanzar excepción, solo loggear - la app seguirá funcionando con placeholders
    
    def get_environmental_data(self, lat, lon, location_name=None, country=None):
        """
        Get comprehensive environmental data for a location in Africa
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            location_name (str, optional): Name of the location
            country (str, optional): Country name
            
        Returns:
            dict: Environmental data including air quality, temperature, etc.
        """
        self._init_copernicus_client()
        
        data = {
            "location": {
                "lat": lat,
                "lon": lon,
                "name": location_name or f"Location ({lat}, {lon})",
                "country": country or "Unknown"
            },
            "timestamp": datetime.now().isoformat()
        }
        
        # Get different environmental indicators
        try:
            # 1. Air quality data
            air_quality = self.get_air_quality(lat, lon)
            data["air_quality"] = air_quality
            
            # 2. Temperature data
            temperature = self.get_temperature(lat, lon)
            data["temperature"] = temperature
            
            # 3. Vegetation coverage (NDVI)
            vegetation = self.get_vegetation_coverage(lat, lon)
            data["vegetation_coverage"] = vegetation
            
            # 4. Water quality indicators (placeholder)
            data["water_quality"] = self.get_water_quality(lat, lon)
            
            # 5. CO2 emissions estimate
            data["co2_emissions"] = self.estimate_co2_emissions(lat, lon)
            
            # 6. Climate risks
            data["climate_risks"] = self.get_climate_risks(lat, lon)
            
        except Exception as e:
            print(f"Error fetching environmental data: {e}")
            data["error"] = str(e)
        
        return data
    
    def get_air_quality(self, lat, lon):
        """
        Get air quality data from Copernicus Atmospheric Monitoring Service
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Air quality indicators (PM2.5, NO2, O3, etc.)
        """
        try:
            self._init_copernicus_client()
            
            if not self.cds_client:
                # Return placeholder if API not configured
                return {
                    "pm25": 0.0,
                    "no2": 0.0,
                    "ozone": 0.0,
                    "status": "API not configured - add COPERNICUS_API_KEY with format UID:KEY"
                }
            
            if not XARRAY_AVAILABLE:
                return {
                    "pm25": 0.0,
                    "no2": 0.0,
                    "ozone": 0.0,
                    "status": "xarray not installed - run: pip install xarray netCDF4"
                }
            
            # Create bounding box around the point (±0.5 degrees)
            north = min(lat + 0.5, 90)
            south = max(lat - 0.5, -90)
            west = max(lon - 0.5, -180)
            east = min(lon + 0.5, 180)
            
            # Try to get the most recent available data
            # CAMS reanalysis typically has 2-5 day delay
            last_error = None
            date_str = None
            
            for days_back in range(2, 15):  # Try from 2 to 14 days ago
                try:
                    target_date = datetime.now() - timedelta(days=days_back)
                    date_str = target_date.strftime('%Y-%m-%d')
                    
                    # Create temporary file
                    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.nc')
                    temp_path = temp_file.name
                    temp_file.close()
                    
                    # Request air quality data from CAMS
                    print(f"[INFO] Trying air quality data from Copernicus for {date_str} ({days_back} days ago)...")
                    
                    self.cds_client.retrieve(
                        'cams-global-reanalysis-eac4',
                        {
                            'date': date_str,
                            'variable': [
                                'particulate_matter_2.5um',
                                'nitrogen_dioxide',
                                'ozone'
                            ],
                            'time': '00:00',
                            'area': [north, west, south, east],  # N, W, S, E
                            'format': 'netcdf'
                        },
                        temp_path
                    )
                    
                    # If we get here, the request succeeded!
                    break
                    
                except Exception as e:
                    last_error = e
                    if os.path.exists(temp_path):
                        os.unlink(temp_path)
                    
                    # Check if it's a "data not available yet" error
                    if "not available yet" in str(e).lower() or "not found" in str(e).lower():
                        print(f"[INFO] Data not available for {date_str}, trying older date...")
                        continue
                    else:
                        # Different error, stop trying
                        raise
            
            # Check if we found valid data
            if date_str and os.path.exists(temp_path):
                try:
                
                    # Read the NetCDF file
                    ds = xr.open_dataset(temp_path)
                    
                    # Extract values (average over the area)
                    pm25 = float(ds['pm2p5'].mean().values) if 'pm2p5' in ds else 0.0
                    no2 = float(ds['no2'].mean().values) if 'no2' in ds else 0.0
                    o3 = float(ds['o3'].mean().values) if 'o3' in ds else 0.0
                    
                    ds.close()
                    
                    print(f"[INFO] ✅ Air quality data retrieved successfully from {date_str}")
                    
                    return {
                        "pm25": round(pm25, 2),  # μg/m³
                        "no2": round(no2, 2),   # μg/m³
                        "ozone": round(o3, 2), # μg/m³
                        "source": "Copernicus CAMS EAC4 Reanalysis",
                        "date": date_str,
                        "days_old": days_back,
                        "status": "success"
                    }
                    
                finally:
                    # Clean up temp file
                    if os.path.exists(temp_path):
                        os.unlink(temp_path)
            else:
                # No data found in the range
                raise Exception(f"No data available in the last 14 days. Last error: {last_error}")
            
        except Exception as e:
            print(f"[ERROR] Air quality retrieval failed: {e}")
            return {
                "error": str(e),
                "pm25": 0.0,
                "no2": 0.0,
                "ozone": 0.0,
                "status": "error"
            }
    
    def get_temperature(self, lat, lon):
        """
        Get temperature data and heat wave risk from Copernicus
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Temperature data and heat indices
        """
        try:
            self._init_copernicus_client()
            
            if not self.cds_client or not XARRAY_AVAILABLE:
                week_ago = datetime.now() - timedelta(days=7)
                date_str = week_ago.strftime('%Y-%m-%d')
                return {
                    "current": 0.0,
                    "average": 0.0,
                    "max_recorded": 0.0,
                    "heat_wave_risk": "unknown",
                    "source": "Copernicus ERA5",
                    "date": date_str,
                    "status": "not_configured"
                }
            
            # Bounding box
            north = min(lat + 0.5, 90)
            south = max(lat - 0.5, -90)
            west = max(lon - 0.5, -180)
            east = min(lon + 0.5, 180)
            
            # Try to get the most recent available data
            # ERA5 typically has 5-7 day delay
            last_error = None
            date_str = None
            temp_path = None
            
            for days_back in range(5, 20):  # Try from 5 to 19 days ago
                try:
                    target_date = datetime.now() - timedelta(days=days_back)
                    date_str = target_date.strftime('%Y-%m-%d')
                    year = target_date.strftime('%Y')
                    month = target_date.strftime('%m')
                    day = target_date.strftime('%d')
                    
                    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.nc')
                    temp_path = temp_file.name
                    temp_file.close()
                    
                    print(f"[INFO] Trying temperature data from Copernicus ERA5 for {date_str} ({days_back} days ago)...")
                    
                    self.cds_client.retrieve(
                        'reanalysis-era5-single-levels',
                        {
                            'product_type': 'reanalysis',
                            'variable': ['2m_temperature'],
                            'year': year,
                            'month': month,
                            'day': day,
                            'time': '12:00',
                            'area': [north, west, south, east],
                            'format': 'netcdf',
                        },
                        temp_path
                    )
                    
                    # If we get here, the request succeeded!
                    break
                    
                except Exception as e:
                    last_error = e
                    if temp_path and os.path.exists(temp_path):
                        os.unlink(temp_path)
                    
                    if "not available yet" in str(e).lower():
                        print(f"[INFO] Data not available for {date_str}, trying older date...")
                        continue
                    else:
                        raise
            
            # Check if we found valid data
            if date_str and temp_path and os.path.exists(temp_path):
                try:
                    ds = xr.open_dataset(temp_path)
                    
                    # Convert from Kelvin to Celsius
                    temp_kelvin = float(ds['t2m'].mean().values)
                    temp_celsius = temp_kelvin - 273.15
                    
                    # Determine heat wave risk
                    if temp_celsius > 35:
                        risk = "high"
                    elif temp_celsius > 30:
                        risk = "medium"
                    else:
                        risk = "low"
                    
                    ds.close()
                    
                    print(f"[INFO] ✅ Temperature data retrieved: {temp_celsius:.1f}°C from {date_str}")
                    
                    return {
                        "current": round(temp_celsius, 1),
                        "heat_wave_risk": risk,
                        "source": "Copernicus ERA5 Reanalysis",
                        "date": date_str,
                        "days_old": days_back,
                        "status": "success"
                    }
                    
                finally:
                    if temp_path and os.path.exists(temp_path):
                        os.unlink(temp_path)
            else:
                raise Exception(f"No temperature data available in the last 20 days. Last error: {last_error}")
            
        except Exception as e:
            print(f"[ERROR] Temperature retrieval failed: {e}")
            yesterday = datetime.now() - timedelta(days=1)
            return {
                "error": str(e),
                "current": 0.0,
                "date": yesterday.strftime('%Y-%m-%d'),
                "status": "error"
            }
    
    def get_vegetation_coverage(self, lat, lon):
        """
        Get vegetation coverage using NDVI from satellite data
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            float: Vegetation coverage percentage
        """
        try:
            # Dataset: satellite-land-cover or NDVI data
            # This helps measure green zones and biodiversity
            
            return {
                "coverage_percentage": 0.0,  # 0-100%
                "ndvi": 0.0,  # -1 to 1
                "green_zones": "low",  # low, medium, high
                "source": "Copernicus Land Monitoring",
                "note": "Implement NDVI calculation"
            }
            
        except Exception as e:
            return {"coverage_percentage": 0.0, "error": str(e)}
    
    def get_water_quality(self, lat, lon):
        """
        Get water quality and pollution indicators
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Water quality indicators
        """
        # This might require additional APIs or datasets
        return {
            "pollution_level": "unknown",
            "access_to_clean_water": None,
            "source": "Pending integration",
            "note": "May require additional data sources"
        }
    
    def estimate_co2_emissions(self, lat, lon):
        """
        Estimate CO2 emissions for the area
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: CO2 emission estimates
        """
        try:
            # Dataset: cams-global-greenhouse-gas-inversion
            # Or use population density + economic activity as proxy
            
            return {
                "emissions_tons_per_year": 0.0,
                "per_capita": 0.0,
                "trend": "stable",  # increasing, stable, decreasing
                "source": "Copernicus CAMS GHG",
                "note": "Implement CO2 emissions retrieval"
            }
            
        except Exception as e:
            return {"emissions_tons_per_year": 0.0, "error": str(e)}
    
    def get_climate_risks(self, lat, lon):
        """
        Assess climate risks (floods, droughts, etc.)
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Climate risk assessment
        """
        return {
            "flood_risk": "medium",  # low, medium, high
            "drought_risk": "medium",
            "extreme_weather_risk": "medium",
            "source": "Copernicus Climate Data Store",
            "note": "Implement climate risk analysis"
        }
    
    def get_biodiversity_index(self, lat, lon):
        """
        Calculate biodiversity index for the area
        
        Args:
            lat (float): Latitude
            lon (float): Longitude
            
        Returns:
            dict: Biodiversity indicators
        """
        return {
            "index": 0.0,  # 0-100
            "species_richness": "unknown",
            "habitat_quality": "unknown",
            "source": "Pending integration",
            "note": "May require specialized biodiversity databases"
        }
